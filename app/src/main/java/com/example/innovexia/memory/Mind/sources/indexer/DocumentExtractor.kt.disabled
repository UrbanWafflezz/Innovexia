package com.example.innovexia.memory.Mind.sources.indexer

import android.util.Log
import com.example.innovexia.memory.Mind.sources.SourcesConfig
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.apache.poi.extractor.ExtractorFactory
import org.apache.poi.xwpf.usermodel.XWPFDocument
import org.apache.poi.xssf.usermodel.XSSFWorkbook
import org.apache.poi.xslf.usermodel.XMLSlideShow
import java.io.File
import java.io.FileInputStream
import java.util.zip.ZipFile

/**
 * Extracts text content from various document formats
 */
class DocumentExtractor(
    private val config: SourcesConfig
) {

    companion object {
        private const val TAG = "DocumentExtractor"
    }

    /**
     * Extract text from a document file
     * @param filePath Path to the document file
     * @param extension File extension (docx, xlsx, etc.)
     * @return List of PageText objects
     */
    suspend fun extractText(filePath: String, extension: String): Result<List<PageText>> =
        withContext(Dispatchers.IO) {
            try {
                val file = File(filePath)
                if (!file.exists()) {
                    return@withContext Result.failure(Exception("File not found: $filePath"))
                }

                val pages = when (extension.lowercase()) {
                    "docx" -> extractFromDocx(file)
                    "xlsx" -> extractFromXlsx(file)
                    "pptx" -> extractFromPptx(file)
                    "odt", "ods", "odp" -> extractFromOpenDocument(file)
                    "rtf" -> extractFromRtf(file)
                    "epub" -> extractFromEpub(file)
                    "doc", "xls", "ppt" -> extractFromLegacyOffice(file)
                    "tex", "latex" -> extractFromLatex(file)
                    else -> listOf(PageText(1, file.readText()))
                }

                Result.success(pages)
            } catch (e: Exception) {
                Log.e(TAG, "Error extracting text from $filePath", e)
                Result.failure(e)
            }
        }

    /**
     * Extract text from DOCX (Word) files
     */
    private fun extractFromDocx(file: File): List<PageText> {
        return try {
            FileInputStream(file).use { fis ->
                val document = XWPFDocument(fis)
                val pages = mutableListOf<PageText>()

                // Extract paragraphs grouped by page breaks or every ~50 paragraphs
                val paragraphs = document.paragraphs
                val paragraphsPerPage = 50

                paragraphs.chunked(paragraphsPerPage).forEachIndexed { index, chunk ->
                    val text = chunk.joinToString("\n") { it.text }
                    if (text.isNotBlank()) {
                        pages.add(PageText(index + 1, text))
                    }
                }

                document.close()
                pages
            }
        } catch (e: Exception) {
            Log.w(TAG, "POI extraction failed for DOCX, falling back to simple extraction", e)
            fallbackExtractFromZip(file)
        }
    }

    /**
     * Extract text from XLSX (Excel) files
     */
    private fun extractFromXlsx(file: File): List<PageText> {
        return try {
            FileInputStream(file).use { fis ->
                val workbook = XSSFWorkbook(fis)
                val pages = mutableListOf<PageText>()

                // Each sheet becomes a "page"
                for (i in 0 until workbook.numberOfSheets) {
                    val sheet = workbook.getSheetAt(i)
                    val text = buildString {
                        appendLine("Sheet: ${sheet.sheetName}")
                        for (row in sheet) {
                            val rowText = row.mapNotNull { cell ->
                                try {
                                    cell.toString()
                                } catch (e: Exception) {
                                    null
                                }
                            }.joinToString("\t")
                            if (rowText.isNotBlank()) {
                                appendLine(rowText)
                            }
                        }
                    }
                    if (text.isNotBlank()) {
                        pages.add(PageText(i + 1, text))
                    }
                }

                workbook.close()
                pages
            }
        } catch (e: Exception) {
            Log.w(TAG, "POI extraction failed for XLSX, falling back to simple extraction", e)
            fallbackExtractFromZip(file)
        }
    }

    /**
     * Extract text from PPTX (PowerPoint) files
     */
    private fun extractFromPptx(file: File): List<PageText> {
        return try {
            FileInputStream(file).use { fis ->
                val ppt = XMLSlideShow(fis)
                val pages = mutableListOf<PageText>()

                // Each slide becomes a "page"
                ppt.slides.forEachIndexed { index, slide ->
                    val text = buildString {
                        appendLine("Slide ${index + 1}")
                        slide.shapes.forEach { shape ->
                            val shapeText = shape.shapeName + "\n" +
                                (shape as? org.apache.poi.xslf.usermodel.XSLFTextShape)?.text
                            if (!shapeText.isNullOrBlank()) {
                                appendLine(shapeText)
                            }
                        }
                    }
                    if (text.isNotBlank()) {
                        pages.add(PageText(index + 1, text))
                    }
                }

                ppt.close()
                pages
            }
        } catch (e: Exception) {
            Log.w(TAG, "POI extraction failed for PPTX, falling back to simple extraction", e)
            fallbackExtractFromZip(file)
        }
    }

    /**
     * Extract text from OpenDocument formats (.odt, .ods, .odp)
     */
    private fun extractFromOpenDocument(file: File): List<PageText> {
        // OpenDocument files are ZIP archives with content.xml
        return fallbackExtractFromZip(file)
    }

    /**
     * Extract text from RTF files
     */
    private fun extractFromRtf(file: File): List<PageText> {
        // Simple RTF extraction - strip RTF commands
        val text = file.readText()
        val stripped = text
            .replace(Regex("""\\[a-z]+(-?\d+)?\s?"""), " ")
            .replace(Regex("""\{|\}"""), "")
            .trim()

        return listOf(PageText(1, stripped))
    }

    /**
     * Extract text from EPUB files
     */
    private fun extractFromEpub(file: File): List<PageText> {
        // EPUB files are ZIP archives containing HTML
        return try {
            val pages = mutableListOf<PageText>()
            var pageNum = 1

            ZipFile(file).use { zip ->
                zip.entries().asSequence()
                    .filter { it.name.endsWith(".html") || it.name.endsWith(".xhtml") }
                    .forEach { entry ->
                        val text = zip.getInputStream(entry).bufferedReader().use { it.readText() }
                        // Basic HTML stripping
                        val stripped = text
                            .replace(Regex("<[^>]+>"), " ")
                            .replace(Regex("\\s+"), " ")
                            .trim()
                        if (stripped.isNotBlank()) {
                            pages.add(PageText(pageNum++, stripped))
                        }
                    }
            }

            pages
        } catch (e: Exception) {
            Log.w(TAG, "Failed to extract EPUB", e)
            listOf(PageText(1, ""))
        }
    }

    /**
     * Extract text from legacy Office formats (.doc, .xls, .ppt)
     */
    private fun extractFromLegacyOffice(file: File): List<PageText> {
        return try {
            FileInputStream(file).use { fis ->
                val extractor = ExtractorFactory.createExtractor(fis)
                val text = extractor.text
                extractor.close()

                // Split into pages of ~1000 words
                val words = text.split(Regex("\\s+"))
                val wordsPerPage = 1000

                words.chunked(wordsPerPage).mapIndexed { index, chunk ->
                    PageText(index + 1, chunk.joinToString(" "))
                }
            }
        } catch (e: Exception) {
            Log.w(TAG, "Failed to extract legacy Office format", e)
            listOf(PageText(1, ""))
        }
    }

    /**
     * Extract text from LaTeX files
     */
    private fun extractFromLatex(file: File): List<PageText> {
        // Basic LaTeX command stripping
        val text = file.readText()
        val stripped = text
            .replace(Regex("""\\[a-zA-Z]+(\[[^\]]*\])?(\{[^}]*\})?"""), " ")
            .replace(Regex("""%.*"""), "")
            .trim()

        val lines = stripped.lines()
        val linesPerPage = 100

        return lines.chunked(linesPerPage).mapIndexed { index, chunk ->
            PageText(index + 1, chunk.joinToString("\n"))
        }
    }

    /**
     * Fallback: Extract text from OpenXML ZIP archives
     */
    private fun fallbackExtractFromZip(file: File): List<PageText> {
        return try {
            val text = buildString {
                ZipFile(file).use { zip ->
                    zip.entries().asSequence()
                        .filter { it.name.endsWith(".xml") }
                        .forEach { entry ->
                            val content = zip.getInputStream(entry).bufferedReader().use { it.readText() }
                            // Strip XML tags
                            val stripped = content
                                .replace(Regex("<[^>]+>"), " ")
                                .replace(Regex("\\s+"), " ")
                            append(stripped)
                            append(" ")
                        }
                }
            }

            listOf(PageText(1, text.trim()))
        } catch (e: Exception) {
            Log.e(TAG, "Fallback extraction failed", e)
            listOf(PageText(1, ""))
        }
    }
}
