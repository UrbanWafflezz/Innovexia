package com.example.innovexia.ui.glass

import android.graphics.Bitmap
import android.graphics.RenderEffect
import android.graphics.Shader
import android.os.Build
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.BoxScope
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawWithCache
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Shape
import androidx.compose.ui.graphics.asComposeRenderEffect
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import kotlin.random.Random

/**
 * Liquid glass surface with blur, gradients, noise, and specular highlights.
 * Auto-adapts to light/dark theme with vibrant colors in dark mode.
 */
@Composable
fun LiquidGlassSurface(
    modifier: Modifier = Modifier,
    shape: Shape = RoundedCornerShape(28.dp),
    tint: Color? = null,
    borderGradient: Brush? = null,
    blurRadius: Dp = 32.dp,
    darkTheme: Boolean = isSystemInDarkTheme(),
    content: @Composable BoxScope.() -> Unit
) {
    val actualTint = tint ?: if (darkTheme) {
        Color.White.copy(alpha = 0.14f)
    } else {
        Color.White.copy(alpha = 0.72f)
    }

    val actualBorder = borderGradient ?: if (darkTheme) {
        Brush.sweepGradient(
            colors = listOf(
                Color(0xFFFF6BD6), // Pink
                Color(0xFF60A5FA), // Blue
                Color(0xFF38E8E1), // Cyan
                Color(0xFFFF6BD6)  // Back to pink
            )
        )
    } else {
        Brush.linearGradient(
            colors = listOf(
                Color.White.copy(alpha = 0.8f),
                Color(0xFFBFE8FF)
            )
        )
    }

    // Generate noise bitmap once
    val noiseBitmap = remember {
        generateNoiseBitmap(256, 256)
    }

    Box(
        modifier = modifier
            .clip(shape)
            .then(
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                    Modifier.graphicsLayer {
                        renderEffect = RenderEffect.createBlurEffect(
                            blurRadius.value,
                            blurRadius.value,
                            Shader.TileMode.CLAMP
                        ).asComposeRenderEffect()
                    }
                } else {
                    Modifier
                }
            )
            .border(1.25.dp, actualBorder, shape)
            .background(actualTint)
            .drawWithCache {
                onDrawBehind {
                    // Top-left specular highlight
                    val highlightTopLeft = Brush.radialGradient(
                        colors = if (darkTheme) {
                            listOf(
                                Color(0xFF38E8E1).copy(alpha = 0.3f),
                                Color.Transparent
                            )
                        } else {
                            listOf(
                                Color.White.copy(alpha = 0.6f),
                                Color.Transparent
                            )
                        },
                        center = Offset(size.width * 0.2f, size.height * 0.2f),
                        radius = size.width * 0.5f
                    )

                    // Bottom-right specular highlight
                    val highlightBottomRight = Brush.radialGradient(
                        colors = if (darkTheme) {
                            listOf(
                                Color(0xFFFF6BD6).copy(alpha = 0.25f),
                                Color.Transparent
                            )
                        } else {
                            listOf(
                                Color(0xFF60A5FA).copy(alpha = 0.3f),
                                Color.Transparent
                            )
                        },
                        center = Offset(size.width * 0.8f, size.height * 0.8f),
                        radius = size.width * 0.6f
                    )

                    drawRect(highlightTopLeft)
                    drawRect(highlightBottomRight)
                }
            }
    ) {
        // Noise overlay
        if (noiseBitmap != null) {
            Image(
                bitmap = noiseBitmap.asImageBitmap(),
                contentDescription = null,
                modifier = Modifier.matchParentSize(),
                contentScale = ContentScale.FillBounds,
                alpha = if (darkTheme) 0.08f else 0.06f
            )
        }

        content()
    }
}

/**
 * Generates a procedural noise bitmap to add texture and prevent banding.
 */
private fun generateNoiseBitmap(width: Int, height: Int): Bitmap? {
    return try {
        val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
        val random = Random(42) // Fixed seed for consistency

        for (y in 0 until height) {
            for (x in 0 until width) {
                val noise = random.nextInt(256)
                val gray = noise and 0xFF
                val pixel = (gray shl 16) or (gray shl 8) or gray or (0xFF shl 24)
                bitmap.setPixel(x, y, pixel)
            }
        }
        bitmap
    } catch (e: Exception) {
        null
    }
}
