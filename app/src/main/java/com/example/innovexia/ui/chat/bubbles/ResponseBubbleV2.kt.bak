package com.example.innovexia.ui.chat.bubbles

import androidx.compose.animation.animateContentSize
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.tween
import androidx.compose.foundation.*
import androidx.compose.foundation.combinedClickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Error
import androidx.compose.material.icons.filled.Refresh
import androidx.compose.foundation.clickable
import androidx.compose.material.icons.outlined.*
import androidx.compose.material3.*
import androidx.compose.ui.hapticfeedback.HapticFeedbackType
import androidx.compose.ui.platform.LocalHapticFeedback
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalClipboardManager
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.AnnotatedString
import androidx.compose.ui.text.SpanStyle
import androidx.compose.ui.text.buildAnnotatedString
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontStyle
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.text.withStyle
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.Dialog
import com.example.innovexia.data.local.entities.MessageEntity
import com.example.innovexia.ui.theme.InnovexiaColors
import java.text.SimpleDateFormat
import java.util.*

/**
 * Advanced Response Bubble V2
 * Premium markdown rendering with dynamic blocks, collapsibles, and modern typography
 */
@Composable
fun ResponseBubbleV2(
    message: MessageEntity,
    modifier: Modifier = Modifier,
    isStreaming: Boolean = false,
    messageStatus: com.example.innovexia.ui.models.MessageStatus = com.example.innovexia.ui.models.MessageStatus.COMPLETE,
    modelName: String = "Innovexia",
    isTruncated: Boolean = false,
    onRegenerate: (String) -> Unit = {},
    onCopy: (String) -> Unit = {},
    onContinue: (String) -> Unit = {}
) {
    // Check if we're in SENDING state or STREAMING state
    val isSending = messageStatus == com.example.innovexia.ui.models.MessageStatus.SENDING
    val streaming = message.getStreamStateEnum() == com.example.innovexia.data.local.entities.StreamState.STREAMING

    // Disable actions while streaming or if there's an error
    val actionsEnabled = !isStreaming && !streaming && message.getStreamStateEnum() != com.example.innovexia.data.local.entities.StreamState.ERROR

    val blocks = remember(message.text, message.id) {
        if (message.text.isNotEmpty()) MarkdownParser.parse(message.text) else emptyList()
    }

    val clipboardManager = LocalClipboardManager.current
    val context = LocalContext.current

    // Better gray colors for premium look
    val isDark = isSystemInDarkTheme()
    val bubbleColor = if (isDark) Color(0xFF1E2329) else Color(0xFFF5F5F7)
    val borderColor = if (isDark) Color(0xFF2A323B).copy(alpha = 0.6f) else Color(0xFFE0E0E3)
    val textPrimary = if (isDark) Color(0xFFECEFF4) else Color(0xFF1C1C1E)
    val textSecondary = if (isDark) Color(0xFFB7C0CC) else Color(0xFF86868B)
    val dividerColor = if (isDark) Color(0xFF2A323B).copy(alpha = 0.4f) else Color(0xFFD1D1D6)

    Surface(
        color = bubbleColor,
        shape = RoundedCornerShape(18.dp),
        tonalElevation = 0.dp,
        shadowElevation = 0.dp,
        border = BorderStroke(1.dp, borderColor),
        modifier = modifier
            .padding(horizontal = 10.dp, vertical = 4.dp)
            .fillMaxWidth()
            .animateContentSize(
                animationSpec = tween(
                    durationMillis = 150,
                    easing = androidx.compose.animation.core.FastOutSlowInEasing
                )
            )
    ) {
        Column {
            // Message content with padding
            Column(
                modifier = Modifier
                    .padding(horizontal = 16.dp, vertical = 12.dp)
                    .animateContentSize(
                        animationSpec = tween(
                            durationMillis = 100,
                            easing = androidx.compose.animation.core.LinearOutSlowInEasing
                        )
                    ),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                // Header row with status pill
                if (streaming) {
                    StatusPill(text = "Regenerating…", textSecondary = textSecondary)
                    Spacer(Modifier.height(4.dp))
                }

                // Show "Sending..." if in SENDING state, otherwise show content
                if (isSending) {
                    SendingIndicator(textSecondary)
                } else if (streaming && message.text.isBlank()) {
                    // Show skeleton while regenerating with no text yet
                    ResponseBubbleSkeleton(textSecondary)
                } else {
                    if (blocks.isNotEmpty()) {
                        MarkdownBody(
                            blocks = blocks,
                            textPrimary = textPrimary,
                            textSecondary = textSecondary,
                            bubbleBorder = borderColor
                        )
                    }

                    if (isStreaming && !streaming) {
                        StreamingIndicator(textSecondary)
                    }
                }

                // Error footer
                if (message.getStreamStateEnum() == com.example.innovexia.data.local.entities.StreamState.ERROR && message.error != null) {
                    Spacer(Modifier.height(6.dp))
                    Text(
                        text = message.error,
                        color = Color(0xFFFF5252),
                        style = MaterialTheme.typography.labelSmall
                    )
                }

                // Truncation footer (token limit reached)
                if (isTruncated && !isStreaming && !streaming) {
                    Spacer(Modifier.height(8.dp))
                    TruncationFooter(
                        textSecondary = textSecondary,
                        onContinue = { onContinue(message.id) }
                    )
                }
            }

            // Footer with divider and actions
            if (!isStreaming && !streaming) {
                FooterRow(
                    message = message,
                    timestamp = message.createdAt,
                    modelName = modelName,
                    textSecondary = textSecondary,
                    dividerColor = dividerColor,
                    actionsEnabled = actionsEnabled,
                    onCopy = onCopy,
                    onRegenerate = onRegenerate
                )
            }
        }
    }
}

@Composable
private fun isSystemInDarkTheme(): Boolean {
    return androidx.compose.foundation.isSystemInDarkTheme()
}

/**
 * Status pill for "Regenerating..." / "Sending..."
 */
@Composable
private fun StatusPill(text: String, textSecondary: Color) {
    val isDark = isSystemInDarkTheme()
    Surface(
        shape = RoundedCornerShape(999.dp),
        color = if (isDark) Color(0xFF2A323B).copy(alpha = 0.5f) else Color(0xFFE0E0E3).copy(alpha = 0.5f)
    ) {
        Text(
            text = text,
            modifier = Modifier.padding(horizontal = 10.dp, vertical = 4.dp),
            style = MaterialTheme.typography.labelSmall.copy(color = textSecondary)
        )
    }
}

/**
 * Skeleton shimmer for loading state
 */
@Composable
private fun ResponseBubbleSkeleton(textSecondary: Color) {
    Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
        repeat(3) {
            Box(
                modifier = Modifier
                    .fillMaxWidth(if (it == 2) 0.6f else 1f)
                    .height(14.dp)
                    .clip(RoundedCornerShape(4.dp))
                    .background(textSecondary.copy(alpha = 0.1f))
            )
        }
    }
}

/**
 * Footer row with branding, timestamp, and action buttons
 */
@Composable
private fun FooterRow(
    message: MessageEntity,
    timestamp: Long,
    modelName: String,
    textSecondary: Color,
    dividerColor: Color,
    actionsEnabled: Boolean,
    onCopy: (String) -> Unit,
    onRegenerate: (String) -> Unit
) {
    val context = LocalContext.current

    // Format time as 12-hour clock (e.g., "2:34 PM")
    val timeStr = remember(timestamp) {
        val sdf = SimpleDateFormat("h:mm a", Locale.getDefault())
        sdf.format(Date(timestamp))
    }

    Column {
        // Divider
        HorizontalDivider(
            color = dividerColor,
            thickness = 1.dp
        )

        // Footer content
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 12.dp, vertical = 8.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            // Left: Model name display
            Text(
                text = modelName,
                style = MaterialTheme.typography.labelSmall.copy(
                    fontSize = 11.sp,
                    fontWeight = FontWeight.Medium,
                    color = textSecondary
                )
            )

            // Action buttons removed - will be added later
            Spacer(Modifier.width(8.dp))

            // Right: Timestamp
            Text(
                text = timeStr,
                style = MaterialTheme.typography.labelSmall.copy(
                    fontSize = 11.sp,
                    color = textSecondary.copy(alpha = 0.7f)
                )
            )
        }
    }
}

/**
 * Markdown body with block-based rendering
 */
@Composable
private fun MarkdownBody(
    blocks: List<MarkdownBlock>,
    textPrimary: Color,
    textSecondary: Color,
    bubbleBorder: Color
) {
    Column(
        modifier = Modifier.fillMaxWidth(),
        verticalArrangement = Arrangement.spacedBy(14.dp)
    ) {
        blocks.forEach { block ->
            when (block) {
                is MarkdownBlock.Paragraph -> TextBlock(block, textPrimary)
                is MarkdownBlock.Heading -> HeadingBlock(block, textPrimary)
                is MarkdownBlock.List -> ListBlock(block, textPrimary)
                is MarkdownBlock.Quote -> QuoteBlock(block, textPrimary, bubbleBorder)
                is MarkdownBlock.Code -> CodeBlockV2(block, textPrimary, textSecondary, bubbleBorder)
                is MarkdownBlock.Table -> TableBlock(block, textPrimary, textSecondary, bubbleBorder)
                is MarkdownBlock.Callout -> CalloutBlock(block, textPrimary)
                is MarkdownBlock.Collapsible -> CollapsibleBlock(block, textPrimary, textSecondary, bubbleBorder)
                is MarkdownBlock.Image -> ImageBlock(block)
                is MarkdownBlock.Divider -> Divider(color = bubbleBorder, thickness = 1.dp)
            }
        }
    }
}

/**
 * Text/Paragraph block
 */
@Composable
private fun TextBlock(block: MarkdownBlock.Paragraph, textPrimary: Color) {
    Text(
        text = parseInlineMarkdown(block.text, textPrimary),
        style = MaterialTheme.typography.bodyMedium.copy(
            lineHeight = 22.sp,
            fontSize = 14.sp,
            color = textPrimary,
            letterSpacing = 0.2.sp
        )
    )
}

/**
 * Heading block
 */
@Composable
private fun HeadingBlock(block: MarkdownBlock.Heading, textPrimary: Color) {
    val (size, topPadding, bottomPadding) = when (block.level) {
        1 -> Triple(20.sp, 8.dp, 4.dp)
        2 -> Triple(18.sp, 6.dp, 3.dp)
        3 -> Triple(16.sp, 4.dp, 2.dp)
        else -> Triple(15.sp, 2.dp, 1.dp)
    }
    Text(
        text = parseInlineMarkdown(block.text, textPrimary),
        fontSize = size,
        fontWeight = FontWeight.Bold,
        lineHeight = (size.value * 1.3).sp,
        color = textPrimary,
        modifier = Modifier.padding(top = topPadding, bottom = bottomPadding)
    )
}

/**
 * List block (ordered/unordered)
 */
@Composable
private fun ListBlock(block: MarkdownBlock.List, textPrimary: Color) {
    Column(verticalArrangement = Arrangement.spacedBy(10.dp)) {
        block.items.forEachIndexed { index, item ->
            // Main list item
            Column {
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 2.dp),
                    horizontalArrangement = Arrangement.spacedBy(10.dp),
                    verticalAlignment = Alignment.Top
                ) {
                    // Render checkbox for task lists
                    if (block.isTaskList) {
                        val isChecked = block.checkedStates.getOrNull(index) ?: false
                        Box(
                            modifier = Modifier
                                .size(20.dp)
                                .border(
                                    width = 2.dp,
                                    color = if (isChecked) InnovexiaColors.Success else textPrimary.copy(alpha = 0.4f),
                                    shape = RoundedCornerShape(4.dp)
                                )
                                .background(
                                    if (isChecked) InnovexiaColors.Success.copy(alpha = 0.1f) else Color.Transparent,
                                    RoundedCornerShape(4.dp)
                                ),
                            contentAlignment = Alignment.Center
                        ) {
                            if (isChecked) {
                                Text(
                                    text = "✓",
                                    fontSize = 12.sp,
                                    fontWeight = FontWeight.Bold,
                                    color = InnovexiaColors.Success
                                )
                            }
                        }
                    } else {
                        Text(
                            text = if (block.ordered) "${index + 1}." else "•",
                            style = MaterialTheme.typography.bodyMedium.copy(
                                fontSize = 14.sp,
                                color = textPrimary.copy(alpha = 0.7f),
                                fontWeight = FontWeight.Medium
                            ),
                            modifier = Modifier.width(24.dp)
                        )
                    }

                    Text(
                        text = parseInlineMarkdown(item, textPrimary),
                        style = MaterialTheme.typography.bodyMedium.copy(
                            lineHeight = 22.sp,
                            fontSize = 14.sp,
                            color = textPrimary,
                            textDecoration = if (block.isTaskList && block.checkedStates.getOrNull(index) == true) {
                                androidx.compose.ui.text.style.TextDecoration.LineThrough
                            } else null
                        ),
                        modifier = Modifier.weight(1f)
                    )
                }

                // Render nested list items if present
                val nestedItems = block.nestedLists.getOrNull(index) ?: emptyList()
                if (nestedItems.isNotEmpty()) {
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(start = 34.dp, top = 4.dp),
                        verticalArrangement = Arrangement.spacedBy(4.dp)
                    ) {
                        nestedItems.forEach { nestedItem ->
                            Row(
                                horizontalArrangement = Arrangement.spacedBy(8.dp),
                                verticalAlignment = Alignment.Top
                            ) {
                                Text(
                                    text = "◦",
                                    style = MaterialTheme.typography.bodySmall.copy(
                                        fontSize = 12.sp,
                                        color = textPrimary.copy(alpha = 0.6f)
                                    ),
                                    modifier = Modifier.width(16.dp)
                                )
                                Text(
                                    text = parseInlineMarkdown(nestedItem, textPrimary),
                                    style = MaterialTheme.typography.bodySmall.copy(
                                        lineHeight = 20.sp,
                                        fontSize = 13.sp,
                                        color = textPrimary
                                    ),
                                    modifier = Modifier.weight(1f)
                                )
                            }
                        }
                    }
                }
            }
        }
    }
}

/**
 * Quote block
 */
@Composable
private fun QuoteBlock(block: MarkdownBlock.Quote, textPrimary: Color, borderColor: Color) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .background(borderColor.copy(alpha = 0.05f), RoundedCornerShape(4.dp))
            .border(
                width = 3.dp,
                color = borderColor.copy(alpha = 0.5f),
                shape = RoundedCornerShape(4.dp)
            )
            .padding(start = 14.dp, top = 10.dp, bottom = 10.dp, end = 10.dp)
    ) {
        Text(
            text = parseInlineMarkdown(block.text, textPrimary),
            style = MaterialTheme.typography.bodyMedium.copy(
                fontSize = 14.sp,
                lineHeight = 22.sp,
                fontStyle = FontStyle.Italic,
                color = textPrimary.copy(alpha = 0.85f),
                letterSpacing = 0.15.sp
            )
        )
    }
}

/**
 * Code block with toolbar
 */
@Composable
private fun CodeBlockV2(
    block: MarkdownBlock.Code,
    textPrimary: Color,
    textSecondary: Color,
    borderColor: Color
) {
    val clipboardManager = LocalClipboardManager.current
    var copied by remember { mutableStateOf(false) }

    LaunchedEffect(copied) {
        if (copied) {
            kotlinx.coroutines.delay(2000)
            copied = false
        }
    }

    Column(
        modifier = Modifier
            .fillMaxWidth()
            .clip(RoundedCornerShape(10.dp))
            .background(MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.3f))
            .border(1.dp, borderColor.copy(alpha = 0.4f), RoundedCornerShape(10.dp))
            .padding(vertical = 10.dp, horizontal = 12.dp)
    ) {
        // Toolbar
        Row(
            Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                text = (block.language?.uppercase() ?: "CODE"),
                style = MaterialTheme.typography.labelSmall.copy(
                    fontSize = 11.sp,
                    fontWeight = FontWeight.SemiBold,
                    color = textSecondary
                )
            )
            Row(horizontalArrangement = Arrangement.spacedBy(4.dp)) {
                IconButton(
                    onClick = {
                        clipboardManager.setText(AnnotatedString(block.code))
                        copied = true
                    },
                    modifier = Modifier.size(28.dp)
                ) {
                    Icon(
                        imageVector = if (copied) Icons.Outlined.Check else Icons.Outlined.ContentCopy,
                        contentDescription = "Copy code",
                        tint = if (copied) InnovexiaColors.Success else textSecondary,
                        modifier = Modifier.size(16.dp)
                    )
                }
                IconButton(
                    onClick = { /* Expand to fullscreen */ },
                    modifier = Modifier.size(28.dp)
                ) {
                    Icon(
                        Icons.Outlined.Fullscreen,
                        contentDescription = "Fullscreen",
                        tint = textSecondary,
                        modifier = Modifier.size(16.dp)
                    )
                }
            }
        }

        Spacer(Modifier.height(8.dp))

        // Code content
        Text(
            text = block.code.trim(),
            fontFamily = FontFamily.Monospace,
            fontSize = 13.sp,
            lineHeight = 20.sp,
            color = textPrimary,
            modifier = Modifier.horizontalScroll(rememberScrollState())
        )
    }
}

/**
 * Callout/Alert block
 */
@Composable
private fun CalloutBlock(block: MarkdownBlock.Callout, textPrimary: Color) {
    val tint = block.type.tintProvider(
        InnovexiaColors.Info,
        InnovexiaColors.Warning,
        InnovexiaColors.Success
    )

    Row(
        Modifier
            .fillMaxWidth()
            .clip(RoundedCornerShape(10.dp))
            .background(tint.copy(alpha = 0.1f))
            .border(1.dp, tint.copy(alpha = 0.3f), RoundedCornerShape(10.dp))
            .padding(10.dp),
        horizontalArrangement = Arrangement.spacedBy(10.dp)
    ) {
        Icon(
            imageVector = block.type.icon,
            contentDescription = null,
            tint = tint,
            modifier = Modifier.size(20.dp)
        )
        Text(
            text = parseInlineMarkdown(block.text, textPrimary),
            style = MaterialTheme.typography.bodyMedium.copy(
                fontSize = 14.sp,
                color = textPrimary
            ),
            modifier = Modifier.weight(1f)
        )
    }
}

/**
 * Collapsible section
 */
@Composable
private fun CollapsibleBlock(
    block: MarkdownBlock.Collapsible,
    textPrimary: Color,
    textSecondary: Color,
    borderColor: Color
) {
    var expanded by remember { mutableStateOf(false) }
    val rotation by animateFloatAsState(
        targetValue = if (expanded) 180f else 0f,
        animationSpec = tween(200),
        label = "arrow_rotation"
    )

    Column(
        Modifier
            .fillMaxWidth()
            .clip(RoundedCornerShape(10.dp))
            .background(borderColor.copy(alpha = 0.06f))
            .animateContentSize()
            .clickable { expanded = !expanded }
            .padding(10.dp)
    ) {
        Row(
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(6.dp)
        ) {
            Icon(
                imageVector = Icons.Outlined.ExpandMore,
                contentDescription = if (expanded) "Collapse" else "Expand",
                tint = textSecondary,
                modifier = Modifier
                    .size(20.dp)
                    .graphicsLayer { rotationZ = rotation }
            )
            Text(
                text = block.title,
                color = textPrimary,
                fontWeight = FontWeight.SemiBold,
                fontSize = 14.sp
            )
        }
        if (expanded) {
            Spacer(Modifier.height(8.dp))
            Text(
                text = parseInlineMarkdown(block.content, textPrimary),
                color = textPrimary,
                fontSize = 14.sp,
                lineHeight = 20.sp
            )
        }
    }
}

/**
 * Table block with horizontal scroll
 */
@Composable
private fun TableBlock(
    block: MarkdownBlock.Table,
    textPrimary: Color,
    textSecondary: Color,
    borderColor: Color
) {
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .clip(RoundedCornerShape(10.dp))
            .border(1.dp, borderColor.copy(alpha = 0.4f), RoundedCornerShape(10.dp))
            .horizontalScroll(rememberScrollState())
    ) {
        // Header row
        Row(
            modifier = Modifier
                .background(borderColor.copy(alpha = 0.12f))
                .padding(horizontal = 14.dp, vertical = 10.dp)
        ) {
            block.headers.forEach { header ->
                Text(
                    text = header,
                    style = MaterialTheme.typography.labelMedium.copy(
                        fontSize = 13.sp,
                        fontWeight = FontWeight.Bold,
                        color = textPrimary,
                        letterSpacing = 0.3.sp
                    ),
                    modifier = Modifier
                        .width(130.dp)
                        .padding(horizontal = 8.dp)
                )
            }
        }

        HorizontalDivider(color = borderColor.copy(alpha = 0.4f), thickness = 1.dp)

        // Data rows
        block.rows.forEachIndexed { rowIndex, row ->
            Row(
                modifier = Modifier
                    .background(
                        if (rowIndex % 2 == 0) Color.Transparent
                        else borderColor.copy(alpha = 0.04f)
                    )
                    .padding(horizontal = 14.dp, vertical = 10.dp)
            ) {
                row.forEach { cell ->
                    Text(
                        text = cell,
                        style = MaterialTheme.typography.bodySmall.copy(
                            fontSize = 13.sp,
                            lineHeight = 18.sp,
                            color = textPrimary
                        ),
                        modifier = Modifier
                            .width(130.dp)
                            .padding(horizontal = 8.dp)
                    )
                }
            }
        }
    }
}

/**
 * Image block with zoom support
 * TODO: Add Coil library for full image loading support
 */
@Composable
private fun ImageBlock(block: MarkdownBlock.Image) {
    // Placeholder for image - will work once Coil is synced
    Box(
        modifier = Modifier
            .fillMaxWidth()
            .height(100.dp)
            .clip(RoundedCornerShape(10.dp))
            .background(MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.3f))
            .border(
                1.dp,
                MaterialTheme.colorScheme.outline.copy(alpha = 0.3f),
                RoundedCornerShape(10.dp)
            ),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            Icon(
                imageVector = Icons.Outlined.Image,
                contentDescription = "Image",
                tint = MaterialTheme.colorScheme.onSurfaceVariant,
                modifier = Modifier.size(32.dp)
            )
            if (block.altText != null) {
                Text(
                    text = block.altText,
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}

/**
 * Sending indicator - shows "Sending..." before response starts
 */
@Composable
private fun SendingIndicator(textSecondary: Color) {
    Row(
        horizontalArrangement = Arrangement.spacedBy(6.dp),
        verticalAlignment = Alignment.CenterVertically,
        modifier = Modifier.padding(vertical = 4.dp)
    ) {
        // Animated dots
        repeat(3) { index ->
            val alpha by animateFloatAsState(
                targetValue = if ((System.currentTimeMillis() / 400 % 3).toInt() == index) 1f else 0.3f,
                animationSpec = tween(400),
                label = "sending_dot_$index"
            )
            Box(
                modifier = Modifier
                    .size(6.dp)
                    .background(
                        color = textSecondary.copy(alpha = alpha),
                        shape = RoundedCornerShape(50)
                    )
            )
        }

        Text(
            text = "Sending",
            fontSize = 13.sp,
            color = textSecondary,
            fontStyle = FontStyle.Italic
        )
    }
}

/**
 * Streaming indicator
 */
@Composable
private fun StreamingIndicator(textSecondary: Color) {
    Row(
        horizontalArrangement = Arrangement.spacedBy(4.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        repeat(3) { index ->
            val alpha by animateFloatAsState(
                targetValue = if ((System.currentTimeMillis() / 400 % 3).toInt() == index) 1f else 0.3f,
                animationSpec = tween(400),
                label = "dot_$index"
            )
            Box(
                modifier = Modifier
                    .size(6.dp)
                    .background(
                        color = textSecondary.copy(alpha = alpha),
                        shape = RoundedCornerShape(50)
                    )
            )
        }
    }
}

/**
 * Truncation footer - shows when response hit token limit
 */
@Composable
private fun TruncationFooter(
    textSecondary: Color,
    onContinue: () -> Unit
) {
    val isDark = isSystemInDarkTheme()
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clip(RoundedCornerShape(8.dp))
            .background(if (isDark) Color(0xFF2A323B).copy(alpha = 0.3f) else Color(0xFFE0E0E3).copy(alpha = 0.3f))
            .clickable { onContinue() }
            .padding(horizontal = 12.dp, vertical = 8.dp),
        horizontalArrangement = Arrangement.spacedBy(8.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Icon(
            imageVector = Icons.Outlined.MoreHoriz,
            contentDescription = "Continue",
            tint = textSecondary,
            modifier = Modifier.size(18.dp)
        )
        Text(
            text = "Response truncated — Continue",
            style = MaterialTheme.typography.labelMedium.copy(
                fontSize = 13.sp,
                fontWeight = FontWeight.Medium,
                color = textSecondary
            ),
            modifier = Modifier.weight(1f)
        )
        Icon(
            imageVector = Icons.Outlined.Refresh,
            contentDescription = "Continue",
            tint = textSecondary,
            modifier = Modifier.size(16.dp)
        )
    }
}

/**
 * Parse inline markdown (bold, italic, strikethrough, code, links)
 * Enhanced for better Gemini compatibility
 */
private fun parseInlineMarkdown(text: String, baseColor: Color): AnnotatedString {
    return buildAnnotatedString {
        var i = 0
        while (i < text.length) {
            when {
                // Bold + Italic: ***text***
                text.substring(i).startsWith("***") -> {
                    val end = text.indexOf("***", i + 3)
                    if (end != -1 && end > i + 3) {
                        withStyle(SpanStyle(fontWeight = FontWeight.Bold, fontStyle = FontStyle.Italic)) {
                            append(text.substring(i + 3, end))
                        }
                        i = end + 3
                    } else {
                        append(text[i])
                        i++
                    }
                }

                // Bold: **text**
                text.substring(i).startsWith("**") -> {
                    val end = text.indexOf("**", i + 2)
                    if (end != -1 && end > i + 2) {
                        withStyle(SpanStyle(fontWeight = FontWeight.Bold)) {
                            append(text.substring(i + 2, end))
                        }
                        i = end + 2
                    } else {
                        append(text[i])
                        i++
                    }
                }

                // Strikethrough: ~~text~~
                text.substring(i).startsWith("~~") -> {
                    val end = text.indexOf("~~", i + 2)
                    if (end != -1 && end > i + 2) {
                        withStyle(SpanStyle(textDecoration = androidx.compose.ui.text.style.TextDecoration.LineThrough)) {
                            append(text.substring(i + 2, end))
                        }
                        i = end + 2
                    } else {
                        append(text[i])
                        i++
                    }
                }

                // Italic: *text* (but not **)
                text.substring(i).startsWith("*") && !text.substring(i).startsWith("**") -> {
                    val end = text.indexOf("*", i + 1)
                    if (end != -1 && end > i + 1 && (end >= text.length - 1 || text[end + 1] != '*')) {
                        withStyle(SpanStyle(fontStyle = FontStyle.Italic)) {
                            append(text.substring(i + 1, end))
                        }
                        i = end + 1
                    } else {
                        append(text[i])
                        i++
                    }
                }

                // Italic: _text_ (but not at word boundaries for snake_case)
                text.substring(i).startsWith("_") && (i == 0 || !text[i - 1].isLetterOrDigit()) -> {
                    val end = text.indexOf("_", i + 1)
                    if (end != -1 && end > i + 1 && (end >= text.length - 1 || !text[end + 1].isLetterOrDigit())) {
                        withStyle(SpanStyle(fontStyle = FontStyle.Italic)) {
                            append(text.substring(i + 1, end))
                        }
                        i = end + 1
                    } else {
                        append(text[i])
                        i++
                    }
                }

                // Inline code: `text`
                text.substring(i).startsWith("`") && !text.substring(i).startsWith("```") -> {
                    val end = text.indexOf("`", i + 1)
                    if (end != -1 && end > i + 1) {
                        // Add padding spaces around inline code
                        append(" ")
                        withStyle(
                            SpanStyle(
                                fontFamily = FontFamily.Monospace,
                                background = baseColor.copy(alpha = 0.15f),
                                fontSize = 13.sp,
                                color = InnovexiaColors.Info,
                                fontWeight = FontWeight.Medium
                            )
                        ) {
                            append(" ${text.substring(i + 1, end)} ")
                        }
                        append(" ")
                        i = end + 1
                    } else {
                        append(text[i])
                        i++
                    }
                }

                // Link: [text](url)
                text.substring(i).startsWith("[") -> {
                    val textEnd = text.indexOf("]", i + 1)
                    val urlStart = text.indexOf("(", textEnd)
                    val urlEnd = text.indexOf(")", urlStart)
                    if (textEnd != -1 && urlStart == textEnd + 1 && urlEnd != -1) {
                        withStyle(
                            SpanStyle(
                                color = InnovexiaColors.BlueAccent,
                                textDecoration = androidx.compose.ui.text.style.TextDecoration.Underline,
                                fontWeight = FontWeight.Medium
                            )
                        ) {
                            append(text.substring(i + 1, textEnd))
                        }
                        i = urlEnd + 1
                    } else {
                        append(text[i])
                        i++
                    }
                }

                // Regular text
                else -> {
                    append(text[i])
                    i++
                }
            }
        }
    }
}
